---
title: Before you begin
---

import { LinkOut } from '@interledger/docs-design-system'

import { Mermaid, CodeBlock } from '@interledger/docs-design-system'

As you begin setting up your production environment, there are a few integration details that should be approached first. Begin by configuring Rafiki to:

- Support cross-currency transactions by providing [exchange rate details](#provide-exchange-rate-details)
- Charge [fees](#charge-fees-for-facilitating-transfers) for facilitating transfers
- Integrate with your [identity provider](#integrate-with-your-identity-provider)
- Establish a mechanism for managing liquidity via [webhook events]

## Provide exchange rate details

To support cross-currency transactions, you must provide Rafiki with an endpoint from where it can fetch current exchange rates.

Jump to [exchange rate environment variables](#exchange-rate-environment-variables).

### Rate probes and slippage

Every Interledger payment is preceded by a rate probe. A rate probe provides a quote that estimates the cost of transferring value over the network, including any fees connector nodes may charge. For the rate probe to be successful, Rafiki needs current exchange rates.

As exchange rates and fees charged by connectors fluctuate, there will likely be a variance between the estimated amount provided in the quote and the actual amount required when the payment is initiated. This difference is called slippage.

Rafiki's default slippage is set to `0.01` (1%). This value can be changed to a value between 0 and 1 via the `SLIPPAGE` variable.

#### Slippage example

Using the default slippage of `0.01` (1%), the rate probe's quote returns `$1.00` USD. A payment of `$1.01` USD will be successful. However, the payment will fail if the total, inclusive of exchange rate and network fees, amounts to `$1.02` USD or more.

### Requests to your exchange rates endpoint

When Rafiki issues a `GET` request to your endpoint, the endpoint must respond with the following.

| Variable             | Type   | Description                                                                                                                        | Required |
| -------------------- | ------ | ---------------------------------------------------------------------------------------------------------------------------------- | -------- |
| `base`               | String | The asset code represented as an <LinkOut href="https://en.wikipedia.org/wiki/ISO_4217">ISO 4217</LinkOut> currency code, e.g. USD | Y        |
| `rates`              | Object | Object containing `<asset_code : exchange_rate>` pairs, e.g. `{EUR: 0.8930}`                                                       | Y        |
| `rates.<asset_code>` | Number | The exchange rate given `base` and `<asset_code>`                                                                                  | Y        |

We provide an <LinkOut href="https://github.com/interledger/rafiki/blob/main/packages/backend/src/openapi/specs/exchange-rates.yaml">OpenAPI specification</LinkOut> for the endpoint, if needed.

Below is a minimalistic example of a successful (200) request, taken from our <LinkOut href="localenv/mock-account-servicing-entity/app/routes/rates.ts">mock account servicing entity</LinkOut>.

```json {13}
import type { LoaderFunctionArgs } from '@remix-run/node'
import { json } from '@remix-run/node'
import { CONFIG as config } from '~/lib/parse_config.server'

export function loader({ request }: LoaderFunctionArgs) {
  const base = new URL(request.url).searchParams.get('base') || 'USD'

  return json(
    {
      base,
      rates: config.seed.rates[base] || {}
    },
    { status: 200 }
  )
}
```

### Exchange rates lifetime

Specify how long your Rafiki instance will cache exchange rates via the `EXCHANGE_RATES_LIFETIME` variable (default is `15_000` ms). Caching improves performance as Rafiki will not need to request the rates from your endpoint for every payment.

### Exchange rate environment variables

The exchange rate environment variables are part of the `backend` service.

The file that contains your variables varies depending on whether you are running Rafiki via Docker (`docker-compose.yaml`) or via Helm and Kubernetes (`values.yaml` for the Helm chart).

| Environment variable      | Description                                                                                     | Required |
| ------------------------- | ----------------------------------------------------------------------------------------------- | -------- |
| `EXCHANGE_RATES_URL`      | Your exchange rates endpoint                                                                    | Y        |
| `EXCHANGE_RATES_LIFETIME` | The amount of time Rafiki caches exchange rates, in ms                                          | Y        |
| `SLIPPAGE`                | The variance allowed between a quote and the actual amount required when a payment is initiated | Y        |

## Charge fees for facilitating transfers

You can charge fees on top of estimated network fees to facilitate transfers. Each asset you support can have a different fee structure.

You can define:

- A fixed fee amount (optional)
- A variable fee amount via basis points (optional)
- Whether the fee is incurred by the sender or the receiver
  :::note
  The Backend Admin API allows you to set one or the other. The [Rafiki Admin app](/admin/admin-user-guide) only allows you to set the fee to be incurred by the sender.
  :::

### Example

For this example, assume the asset scale is 2. You'll charge a fixed fee of 100 (`$1.00`) and a variable fee of 100 (`1%`).

#### Backend Admin API `setFee` mutation

<CodeBlock title="Example setFee mutation">
```graphql
mutation SetFee($input: SetFeeInput!) {
  setFee(input: $input) {
    code
    success
    message
    fee {
      id
      assetId
      type
      fixed
      basisPoints
      createdAt
    }
  }
}
```
</CodeBlock>

#### JSON Request

<CodeBlock title="Example Request">
```json
{
  "input": {
    "assetId": "14863f6f-4bda-42ef-8715-bf4762898af8",
    "type": "SENDING",
    "fee": {
      "fixed": 100,
      "basisPoints": 100
    }
  }
}
```
</CodeBlock>

| Variable      | Description                                                                                                                                                                                                                |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `assetId`     | The unique ID assigned by Rafiki when the asset was created.                                                                                                                                                               |
| `type`        | Indicates who incurs the fee: either the sender (`SENDING`) or receiver (`RECEIVING`).                                                                                                                                     |
| `fixed`       | The amount of the flat, fixed fee to charge. Assuming USD with an asset scale of 2, a value of `100` equals `$1.00`.                                                                                                       |
| `basisPoints` | The amount of the variable fee to charge based on the total amount. One basis point is equal to 0.01% of the total amount. 100 basis points equals 1%, and 10000 basis points equals 100%. In this example, the fee is 1%. |

#### JSON Response

<CodeBlock title="Example Successful Response">
```json
{
  "data": {
    "setFee": {
      "code": "200",
      "success": true,
      "message": "Fee set",
      "fee": {
        "id": "140fd9c0-8f14-4850-9724-102f04d97e69",
        "assetId": "14863f6f-4bda-42ef-8715-bf4762898af8",
        "type": "SENDING",
        "fixed": "100",
        "basisPoints": 100,
        "createdAt": "2023-09-13T14:59:53.435Z"
      }
    }
  }
}
```
</CodeBlock>

## Integrate with your identity provider

## Webhook Events

Rafiki does not hold user account balances but tracks liquidity within asset, peer, and payment accounts in its own database. To effectively manage liquidity, you need to expose an endpoint that listens for specific events dispatched by Rafiki. These events notify your system of time-sensitive status updates, warnings, and errors.

When an event occurs in your Rafiki instance, the Rafiki `backend` service sends a POST request to your configured `WEBHOOK_URL` [environment variable](/resources/environment-variables/). Your endpoint must respond with a 200 status code to confirm a successful receipt.

### Request body

Each webhook event is sent as JSON payload that follows a similar format:

| **Attribute** | **Type**                  | **Description**                                     | **Required?** |
| ------------- | ------------------------- | --------------------------------------------------- | ------------- |
| `id`          | String                    | Unique webhook event ID                             | Y             |
| `type`        | [EventType](#event-types) | `EventType` value                                   | Y             |
| `data`        | Object                    | Additional data that coincides with the `EventType` | Y             |

### Event types

The following is an enumeration of all the event types along with their descriptions, which you must listen to and handle.

| Value                                                                | Description                                                                        |
| -------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
| [`incoming_payment.created`](#incoming_paymentcreated)               | An incoming payment has been created.                                              |
| [`incoming_payment.completed`](#incoming_paymentcompleted)           | An incoming payment is complete and will not accept any additional incoming funds. |
| [`incoming_payment.expired`](#incoming_paymentexpired)               | An incoming payment expired and will not accept any additional incoming funds.     |
| [`outgoing_payment.created`](#outgoing_paymentcreated)               | An outgoing payment was created.                                                   |
| [`outgoing_payment.completed`](#outgoing_paymentcompleted)           | An outgoing payment completed.                                                     |
| [`outgoing_payment.failed`](#outgoing_paymentfailed)                 | An outgoing payment partially or completely failed.                                |
| [`wallet_address.not_found`](#wallet_addressnot_found)               | A requested wallet address was not found.                                          |
| [`wallet_address.web_monetization`](#wallet_addressweb_monetization) | Web Monetization payments received via STREAM.                                     |
| [`asset.liquidity_low`](#assetliquidity_low)                         | Asset liquidity has dropped below defined threshold.                               |
| [`peer.liquidity_low`](#peerliquidity_low)                           | Peer liquidity has dropped below defined threshold.                                |

An OpenAPI specification of the webhook requests and their corresponding data can be found <LinkOut href='https://github.com/interledger/rafiki/blob/main/packages/backend/src/openapi/specs/webhooks.yaml'>here</LinkOut>.

Additionally, the local playground playground contains example payloads in the Bruno collection that can be used to test a webhook service integration.

#### Incoming payment events

BD - Need updated workflow info/overview of incoming payments

Incoming payment events

| **Attribute**     | **Type** | **Description**                                                                                    | **Required?** |
| ----------------- | -------- | -------------------------------------------------------------------------------------------------- | ------------- |
| `id`              | String   | Incoming payment ID                                                                                | **Y**         |
| `walletAddressId` | String   | ID of the wallet address under which this incoming payment was created                             | **Y**         |
| `client`          | String   | Information about the wallet address of the Open Payments client that created the incoming payment | N             |
| `completed`       | Boolean  | True if the incoming payment has completed receiving funds                                         | **Y**         |
| `incomingAmount`  | Object   | The maximum amount that should be paid into the wallet address under this incoming payment         | N             |
| `receivedAmount`  | Object   | The total amount that has been paid into the wallet address under this incoming payment            | **Y**         |
| `metadata`        | Object   | Additional metadata associated with the incoming payment                                           | N             |
| `createdAt`       | String   | Date-time of creation                                                                              | **Y**         |
| `updatedAt`       | String   | Date-time of last update                                                                           | **Y**         |
| `expiresAt`       | String   | Date-time of payment expiration                                                                    | **Y**         |

##### `incoming_payment.created`

The `incoming_payment.created` event indicates that an incoming payment was created. No funds are received in your Rafiki instance, so no action is required. This webhook event is informational and allows you to display upcoming incoming payments to your users.

<Mermaid
  graph={`sequenceDiagram
    participant ASE as Account Servicing Entity
    participant R as Rafiki

    R->>ASE: webhook event: incoming payment created
    ASE->>ASE: no action required

`}
/>

##### `incoming_payment.completed`

The `incoming_payment.completed` event indicates that an incoming payment was completed, either automatically or manually, and that any funds received into this incoming payment should be withdrawn and credited to the recipient’s account on your ledger.

In addition, the `CreateIncomingPaymentWithdrawal` supports two-phase transfers.

Example: An incoming payment was completed and the recipient received **$10**.

<Mermaid
  graph={`sequenceDiagram
    participant ASE as Account Servicing Entity
    participant R as Rafiki

    R->>ASE: webhook event: incoming payment completed,<br>receivedAmount: $10
    ASE->>R: admin API call: CreateIncomingPaymentWithdrawal
    ASE->>ASE: credit receiver's account with $10

`}
/>

Example: An incoming payment supporting two-phase transfers was completed and received **$10**.

<Mermaid
  graph={`sequenceDiagram
    participant ASE as Account Servicing Entity
    participant R as Rafiki

      R->>ASE: webhook event: incoming payment completed,<br>receivedAmount: $10
      ASE->>R: admin API call: CreateIncomingPaymentWithdrawal
      ASE->>ASE: credit receiver's account with $10
      ASE->>R: admin API call: PostLiquidityWithdrawal
      R->>R: 2-phase transfer completed

`}
/>

##### `incoming_payment.expired`

The `incoming_payment.expired` event indicates that an incoming payment has expired and that any funds previously received for this incoming payment should be withdrawn and credited to the recipient’s account on your ledger. Note that this event is only fired if funds were received for the incoming payment. In cases where the sender did not specify the `incomingAmount` when the `incomingPayment` resource was initially created, the `incoming_payment.expired` event notifies you that no further payments are expected. The primary use case of the `incoming_payment.expired` event to signal the end of any additional payments is a streaming payments example, such as <LinkOut href='https://webmonetization.org'>Web Monetization</LinkOut>.

Example: An incoming payment has expired and received **$2.55**.

<Mermaid
  graph={`sequenceDiagram
    participant ASE as Account Servicing Entity
    participant R as Rafiki

    R->>ASE: webhook event: incoming payment expired,<br>receivedAmount: $2.55
    ASE->>R: admin API call: CreateIncomingPaymentWithdrawal
    ASE->>ASE: credit receiver's account with $2.55

`}
/>

#### Outgoing payment events

BD - Need updated workflow info/overview of outgoing payments

Outgoing payment events

    | **Attribute**     | **Type** | **Description**                                                                                    | **Required?** |

|-------------------|----------|----------------------------------------------------------------------------------------------------|---------------|
| `id` | String | Incoming payment ID | **Y** |
| `walletAddressId` | String | ID of the wallet address under which this incoming payment was created | **Y** |
| `client` | String | Information about the wallet address of the Open Payments client that created the incoming payment | N |
| `state` | String | Outgoing payment state, either `PENDING`, `PROCESSING`, `COMPLETED`, or `EXPIRED` | **Y** |
| `receiver` | String | Wallet address URL of the receiver | **Y** |
| `debitAmount` | Object | Amount to send (fixed send) | **Y** |
| `sentAmount` | Object | Amount to receive (fixed receive) | **Y** |
| `metadata` | Object | Additional metadata associated with the outgoing payment | N |
| `createdAt` | String | Date-time of creation | **Y** |
| `updatedAt` | String | Date-time of last update | **Y** |
| `expiresAt` | String | Date-time of payment expiration | **Y** |
| `error` | String | ?? | N |
| `stateAttempts` | Integer | ?? | **Y** |
| `balance` | String | ?? | **Y** |
| `peerId` | String | ?? | N |

##### `outgoing_payment.created`

The `outgoing_payment.created` event indicates that an outgoing payment was created and is awaiting liquidity. You should verify the sender’s account balance and perform other verifications before funding or canceling the outgoing payment in case the sender has insufficient funds in their account. If the outgoing payment is not fulfilled, you can cancel it. Otherwise, you must put a hold on the sender’s account and deposit the funds into Rafiki.

Example: An outgoing payment for **&dollar;12** has been created.

<Mermaid
  graph={`sequenceDiagram
    participant ASE as Account Servicing Entity
    participant R as Rafiki
    R->>ASE: webhook event: outgoing payment created,<br>debitAmount: $12
    ASE->>ASE: check if account has enough balance
    alt Account has enough balance
    ASE->>ASE: put hold of $12 on sender's account
    ASE->>R: admin API call: DepositOutgoingPaymentLiquidity
    end
    alt Account does not have enough balance
    ASE->>R: admin API call: CancelOutgoingPayment<br>reason: Not enough balance
    end

`}
/>

##### `outgoing_payment.completed`

The `outgoing_payment.completed` event indicates that an outgoing payment has successfully sent as many funds as possible to the receiver against the associated incoming payment. You should withdraw any excess liquidity from that outgoing payment in Rafiki that arises from differences between the sent and received amounts and use it as you see fit. One option would be to return it to the sender. Another option is to retain the excess liquidity as a service fee. Furthermore, you should remove the hold on the sender’s account and debit it.

In addition, the `CreateOutgoingPaymentWithdrawal` supports [two-phase transfers](https://rafiki.dev/reference/glossary/#two-phase-transfers).

Example: An outgoing payment amount for **&dollar;12** has been completed. **&dollar;11.50** were sent. You keep **$0.50** as fees.

<Mermaid
  graph={`sequenceDiagram
    participant ASE as Account Servicing Entity
    participant R as Rafiki

    R->>ASE: webhook event: outgoing completed,<br>debitAmount: $12, sentAmount:$11.50
    ASE->>R: admin API call: CreateOutgoingPaymentWithdrawal
    ASE->>ASE: remove the hold and deduct $12 from the sender's account,<br>credit ASE's account with $0.50

`}
/>

Example: An outgoing payment supporting two-phase transfers for **&dollar;12** has been completed. **&dollar;11.50** were sent. You keep **$0.50** as fees.

<Mermaid
  graph={`sequenceDiagram
    participant ASE as Account Servicing Entity
    participant R as Rafiki

        R->>ASE: webhook event: outgoing completed,<br>debitAmount: $12, sentAmount:$11.50
        ASE->>R: admin API call: CreateOutgoingPaymentWithdrawal
        ASE->>ASE: remove the hold and deduct $12 from the sender's account,<br>credit ASE's account with $0.50
        ASE->>R: admin API call: PostLiquidityWithdrawal
        R->>R: 2-phase transfer completed

`}
/>

##### `outgoing_payment.failed`

The `outgoing_payment.failed` event indicates that an outgoing payment has either partially or completely failed and a retry was unsuccessful. You should withdraw any remaining liquidity from that outgoing payment in Rafiki. If the payment failed completely (the `sentAmount` was 0), you should remove the hold from the sender’s account. If the payment failed partially, you should remove the hold from the sender’s account and debit it with the amount sent. Considering the discrepancy between the quote amount and the amount sent, you should refrain from taking a sending fee.

Example: An outgoing payment for **&dollar;12** has failed. **$8** were sent.

<Mermaid
  graph={`sequenceDiagram
    participant ASE as Account Servicing Entity
    participant R as Rafiki

    R->>ASE: webhook event: outgoing failed,<br>debitAmount: $12, sentAmount:$8
    ASE->>R: admin API call: CreateOutgoingPaymentWithdrawal
    ASE->>ASE: remove the hold and deduct $8 from the sender's account

`}
/>

#### Wallet address events

BD - Need updated workflow info/overview of wallet address events

##### `wallet_address.web_monetization`

The `wallet_address.web_monetization` event indicates that a wallet address received Web Monetization payments via the ILP STREAM protocol. You should withdraw that liquidity from the wallet address in Rafiki and credit the receiver’s account on your ledger.

Example: A wallet address received **$0.33**

<Mermaid
  graph={`sequenceDiagram
    participant ASE as Account Servicing Entity
    participant R as Rafiki

    R->>ASE: webhook event: wallet address web monetization,<br>receivedAmount: $0.33
    ASE->>R: admin API call: CreateWalletAddressWithdrawal
    ASE->>ASE: credit receiver's account with $0.33

`}
/>

##### `wallet_address.not_found`

The `wallet_address.not_found` event indicates that a wallet address was requested via the Open Payments Wallet address server API, but it doesn’t exist in your Rafiki instance. When receiving this event, you can look up the associated account in your system and create a wallet address. The initial request for the wallet address will succeed if you create it within the configured `WALLET_ADDRESS_LOOKUP_TIMEOUT_MS` time frame.

Example: The wallet address `https://example-wallet.com/carla_garcia` was requested but does not exist yet.

<Mermaid
  graph={`sequenceDiagram
    participant ASE as Account Servicing Entity
    participant R as Rafiki

    R->>ASE: webhook event: wallet address not found,<br>wallet address: https://example-wallet.com/carla_garcia
    ASE->>R: admin API call: CreateWalletAddress<br>url: https://example-wallet.com/carla_garcia,<br>public name: Carla Eva Garcia

`}
/>

#### Liquidity events

BD - Need updated workflow info/overview of asset/peer liquidity events

##### `asset.liquidity_low`

The `asset.liquidity_low` event indicates that an asset’s liquidity has dropped below a predefined liquidity threshold. When receiving this event, you should check if you already have or can acquire additional liquidity for that specific asset and, if so, deposit it in Rafiki. Cross-currency transfers will fail if you do not increase that asset’s liquidity in Rafiki.

Example: The asset liquidity for USD (scale: 2) drops below **$100.00**.

<Mermaid
  graph={`sequenceDiagram
    participant ASE as Account Servicing Entity
    participant R as Rafiki

    R->>ASE: webhook event: liquidity (asset) low,<br>asset: USD (scale: 2, id: "abc")
    ASE->>R: admin API call: DepositAssetLiquidity

`}
/>

##### `peer.liquidity_low`

The `peer.liquidity_low` event indicates that a peer’s liquidity has dropped below a predefined liquidity threshold. When receiving this event, you must decide if you want to extend that peer’s credit line or whether the peer must settle first and then extend a new line of credit to that peer. If you cannot or do not increase the peer liquidity in Rafiki, transfers to that peer will fail.

Example: The peer liquidity for Happy Life Bank drops below **$100.00**.

<Mermaid
  graph={`sequenceDiagram
    participant ASE as Account Servicing Entity
    participant R as Rafiki

    R->>ASE: webhook event: liquidity (peer) low,<br>peer: Happy Life Bank (asset: "USD", scale: 2, id: "abc")
    ASE->>R: admin API call: DepositPeerLiquidity

`}
/>

### Error handling

If an error occurs when Rafiki sends a webhook event (i.e., a non-200 status is returned or the request timed out), Rafiki will retry the webhook requests at increasing intervals until a 200 status is returned. The first retry is after 10 seconds, the second after 20 more, the next after 30 more, etc. The maximum number of retries for webhook events is configured via the `WEBHOOK_MAX_RETRY` environment variable.

Additionally, the timeout for webhook requests is configured with the `WEBHOOK_TIMEOUT` environment variable.

### Best Practices

#### Duplicate Events

The `id` in the webhook event payload is a unique UUID, which your system can use to determine whether the event has been received previously, preventing duplicate event processing.

#### Asynchronous Handling

Consider using a worker to process received webhook events, especially if requests to credit/debit user accounts are lengthy processes. Doing so allows the server to process events at a rate suitable for the system and reduce the number of failed/retried webhook events since the webhook event listener can immediately reply with a successful 200 status.
